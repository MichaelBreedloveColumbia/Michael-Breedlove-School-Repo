# Overview
This assignment exists to demonstrate my understanding of data structures.
In my program, I do this by generating 10 random numbers, writing them to an array, stack, queue, and dictionary, then printing the contents of those structures along with an explanation of each.

## Arrays
An array is a collection of data stored in "slots", identified by a given numeric value. They start at 0, and can have a defined size or an undefined size, the latter of which is treated as infinite. Arrays are incredibly versatile, and can be used practically anywhere to great effect. They are by far the most common type of data structure, excelling in simplicity and swift look-ups, but there are rare circumstances in which other structures may be preferred. In situations where you will always need to access the newest or oldest item in the collection, or where two objects of different types must be directly linked to each other, it is best to use a different data structure. However, in practically every other situation, an array is the best choice.

## Stacks
A stack is a collection of data which operates under LIFO logic, or last-in-first-out. This is precisely what it sounds like: the most recent object added to a stack is the first object it will be able to access. Objects can be added to a stack by calling StackName.Push(object), or read and removed from the stack by calling StackName.Pop(). To read the next item in the stack without removing it, you may call StackName.Peek(). By their nature, stacks are incredibly specialized, having only one real situation in which they are the most effective choice, being situations in which you will always need to access the newest item in the collection. They more than make up for this, however, by being incredibly fast.

## Queues
A queue is the inverse of a stack, operating exactly the same, but backwards. They utilize FIFO logic, or first-in-first-out. Instead of always accessing the newest item added, a queue will always access its oldest item. To add an item to a queue, you may call QueueName.Queue(object). To read an item in a queue and remove it from said queue, you may call QueueName.Dequeue(). To read the next item in a queue without removing it, simply use QueueName.Peek(). Just like stacks, queues only really have one situation in which they are the best choice, which is to say situations when you will always need to access the oldest item in the collection. In return for this restriction, queues are extremely fast.

## Dictionaries/Maps
Dictionaries, which are very similar to hash tables and maps, are a very specialized type of data structure. They exist as a collection of key-value pairs, in which one data type, the key, is directly connected to another data type, the value. One may picture a dictionary as a two-dimensional array, in which both dimensions can be their own type, rather than both needing to be the same. They excel in terms of swift look-ups, and because nearly any hashable type may be used as a key or value, they are very flexible. However, they suffer in terms of organization, lacking a particular order. If you need to find a value stored in a dictionary base on a specific quality, be it age, size, within a range, you will need to search through the entire dictionary. They are also one-directional; it is very easy to find the value which is tied to a given key, provided you already have the key, but the reverse - which is, to say, finding the key which is tied to a given value - requires the author to manually search the entire dictionary. A dictionary is best used under circumstances in which two objects of different types are directly linked to each other, as this allows us to make the most of the dictionary's unique strengths, while mitigating its weaknesses.
